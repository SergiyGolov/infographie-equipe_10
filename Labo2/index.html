<!DOCTYPE>
<html lang="fr">

<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="css/stylesheet.css" />

  <!-- WEBGL SCRIPTS -->
  <script src="js/commonFunctions.js"></script>
  <script src="js/gl-matrix-min.js"></script>
  <script src="js/webglTools.js"></script>

  <!-- Our lavalamp script -->
  <script src="js/labo2.js"></script>

</head>

<body onload="initWebGL()">
  <canvas id="webgl-canvas" width="600" height="800">
    HTML5 is not supported
  </canvas>
</body>

<script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      void main(void) {
          gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
      }
    </script>
<script id="shader-fs" type="x-shader/x-fragment">
      #ifdef GL_ES
            precision highp float;
      #endif

      const int NB_METABALLS=15;
      float SQUEEZE_MAX=250.0;


      uniform vec4 uMetaballs[NB_METABALLS];
      uniform float uMetaballsSqueezes[NB_METABALLS];
      uniform vec2 uLight;

      // values between 0.0 and 1.0
      uniform float uLampWidthMin;
      uniform float uLampWidthMax;
      uniform float uLampTopHeight;
      uniform float uLampBotHeight;

      float WIDTH=600.0;
      float HEIGHT=800.0;


      void main()
      {
            float x = gl_FragCoord.x;
            float y = gl_FragCoord.y;

            // Sorry for the ugliness of this but it can't be done in an other way with this kind of rendering technique for "metaballs"
            float halfWidth = WIDTH / 2.0;
            float lampTopHeight = uLampTopHeight * HEIGHT;
            float lampBotHeight = uLampBotHeight * HEIGHT;
            float smallerRingRadius = halfWidth * uLampWidthMin;
            float greaterRingRadius = halfWidth * uLampWidthMax;

            if(y < lampBotHeight) // Bottom of the lamp
            {
                  float lampDY = y / lampBotHeight;
                  float lampDX = greaterRingRadius - smallerRingRadius;
                  float lampDif = lampDX * lampDY;
                  float lampFinalX = lampDif + smallerRingRadius;

                  if(x < (halfWidth - lampFinalX) || x > (halfWidth + lampFinalX))
                        gl_FragColor = vec4(1.0,1.0,1.0,1.0);
                  else
                        gl_FragColor = vec4(0.0,0.0,0.0,1.0);
            }
            else if(y > HEIGHT - lampTopHeight) // Top of the lamp
            {
                  float lampDY = (y - HEIGHT) / lampTopHeight;
                  float lampDX = smallerRingRadius - greaterRingRadius;
                  float lampDif = lampDX * lampDY;
                  float lampFinalX = lampDif + smallerRingRadius;

                  if(x < (halfWidth - lampFinalX) || x > (halfWidth + lampFinalX))
                        gl_FragColor = vec4(1.0,1.0,1.0,1.0);
                  else
                        gl_FragColor = vec4(0.0,0.0,0.0,1.0);
            }
            else // Draw lava
            {
                  
                  if (abs(x - uLight.x) < greaterRingRadius && abs(y - uLight.y) < HEIGHT)
                  {
                        float v = 0.0;

                        for (int i = 0; i < NB_METABALLS; i++) {

                              vec4 mb = uMetaballs[i];
                              float weight = mb.w;
                              float squeeze = uMetaballsSqueezes[i];
                              float dx = mb.x - x;
                              float dy = mb.y - y;
                              float r = mb.z;
                              float SQUEEZE_Y_TRANSLATE=r/23.0;
                              if(squeeze>0.0 && squeeze<SQUEEZE_MAX/2.0)
                              {
                                    dx/=(SQUEEZE_MAX/(SQUEEZE_MAX-squeeze));
                                    dy+=r*squeeze/SQUEEZE_MAX;
                                    dy*=(SQUEEZE_MAX/(SQUEEZE_MAX-squeeze));



                              }else if(squeeze>0.0 && squeeze>=SQUEEZE_MAX/2.0)
                              {
                                    dx/=(SQUEEZE_MAX/squeeze);
                                    dy+=r*(1.0-squeeze/SQUEEZE_MAX);
                                    dy*=(SQUEEZE_MAX/squeeze);

                              }

                              v += weight*r*r/(dx*dx + dy*dy);
                        }

                        vec2  ray = vec2(x - uLight.x, y - uLight.y);
                        float luminosity = sqrt(ray.x * ray.x + ray.y * ray.y);
                        if (v >= 2.0)
                        {
                              gl_FragColor = vec4(250.0/luminosity, 0.0, 0.0, 1.0);
                        } else {
                              gl_FragColor = vec4(100.0/luminosity, 50.0/luminosity, 0.0, 0.5);
                        }
                  }
            }
      }
      </script>
</html>
